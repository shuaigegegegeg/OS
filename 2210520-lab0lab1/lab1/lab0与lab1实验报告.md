# `lab0`与`lab1`实验报告

## `lab0`

### 练习1

练习1的要求是让使用`make debug`和`make gdb` 指令调试`QEMU`模拟的`RISC-V`计算机加电开始运行到执行应用程序的第一条指令（即跳转到`0x80200000`）这个阶段的执行过程，于是首先使用了`make gdb` 指令以及`x/10i $pc`来进行调试得到如下的结果：

```assembly
0x0000000000001000 in ?? ()
(gdb) x/10i $pc
=> 0x1000:	auipc	t0,0x0
   0x1004:	addi	a1,t0,32
   0x1008:	csrr	a0,mhartid
   0x100c:	ld	t0,24(t0)
   0x1010:	jr	t0
   0x1014:	unimp
   0x1016:	unimp
   0x1018:	unimp
   0x101a:	0x8000
   0x101c:	unimp
```

从这个结果中我们可以看出RISC-V计算机加电后首先从`0x1000`处开始取指令进行运行，在我们使用`si`指令进行一步步调试中发现程序会顺序执行到`0x1010`处，在这其中的程序是对`to`寄存器以及`a0`，`a1`寄存器的初始化赋值，由于程序会在`0x1010`处的指令进行跳转，这其中跳转的地址与`to`寄存器的值有关，所以下面我们具体来关注这段程序中的`to`寄存器的值是如何变化的。

其中在跳转指令之前为`to`寄存器赋值的指令也就只有两条，分别为：

```assembly
0x1000:	auipc	t0,0x0
0x100c:	ld	t0,24(t0)
```

上面三条指令中第一条指令将用于将一个立即数0加上`PC`的当前值的高位部分，并将结果存储到寄存器`to`中，所以这行代码运行完后的`to`的值为`0x1000`，第二条指令是向`to`寄存器的值加上24得到的地址中取值并将其再次存进`to`寄存器中，由于`to`寄存器当前的值为`0x1000`，所以加上24后的值为`0x1018`，所以要向地址为`0x1018`的地方取值放进`to`寄存器中，查看地址为`0x1018`的地方的值：

```assembly
0x000000000000100c in ?? ()
(gdb) x/10xw 0x1018    
0x1018:	0x80000000	0x00000000	0xedfe0dd0	0x260d0000
0x1028:	0x38000000	0xb00b0000	0x28000000	0x11000000
0x1038:	0x02000000	0x00000000
```

查找得到该地址上的值为`0x80000000`，于是to寄存器的值将会被赋值为`0x80000000`，并且程序在运行到这条指令也会跳转到`0x80000000`执行后续的代码：

```assembly
0x1010:	jr	t0
```

```assembly
0x0000000080000000 in ?? ()
(gdb) x/10i $pc
=> 0x80000000:	csrr	a6,mhartid
   0x80000004:	bgtz	a6,0x80000108
   0x80000008:	auipc	t0,0x0
   0x8000000c:	addi	t0,t0,1032
   0x80000010:	auipc	t1,0x0
   0x80000014:	addi	t1,t1,-16
   0x80000018:	sd	t1,0(t0)
   0x8000001c:	auipc	t0,0x0
   0x80000020:	addi	t0,t0,1020
   0x80000024:	ld	t0,0(t0)
```

在`0x80000000`后运行的指令会根据当前的线程数判断是否跳转，当然在我们的程序中这个跳转并不会执行，因为当前的`a6`值为0，后面在运行到`0x80000020`之前的代码就是对`to`和`t1`寄存器进行赋值，并根据它们的值向某地址进行写操作，这一部分的内容应该是在执行应用程序的第一条指令（即跳转到`0x80200000`）前进行相应的初始化的工作。

## `lab1`

### 练习1

这个练习是让我们阅读`kern/init/entry.S`内容代码，分析其中一些语句的作用：

`la sp, bootstacktop` 完成了什么操作，目的是什么？

这条指令是将` bootstacktop` 的地址，也就是启动栈的顶部地址，加载到栈指针寄存器 `sp` 中。

这条指令的目的是为了初始化系统的栈空间，因为操作系统需要栈来存储局部变量、函数调用过程中的上下文等，所以在启动阶段需要一个启动栈来支持这些操作。

`tail kern_init `完成了什么操作，目的是什么？

用于在初始化启动栈后跳转到 `kern_init` 函数执行初始化的操作。

目的都是将控制权从` kern_entry `入口传递给 `kern_init` 函数，负责完成内核的进一步的初始化工作。

***

### 练习2

在练习2中是对时钟中断进行处理的部分填写，使其完成一定的输出作用，填写的代码如下：

```c++
case IRQ_S_TIMER:
            clock_set_next_event();
            ticks=ticks+1;
            if(ticks==TICK_NUM)
            {
            	print_ticks();
            	ticks=0;
            	num++;
            }
            if(num==10)
            {
            	sbi_shutdown();
            }
            break;
```

补全代码后输出的内容如下，能够完成指定的输出内容：

```
Kernel executable memory footprint: 17KB
++ setup timer interrupts
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
```

实现的过程就是程序进入该中断处理函数后，在进行处理这一次中断和输出内容之前首先要设置下一次的中断，设置完下一次的中断后将中断计数器（`ticks`）的值加一，判断当中断计数器的值达到100的时候输出`100ticks`，并将中断计数器（`ticks`）归零，最后当打印`100ticks`10次后调用`sbi_shutdown`函数进行关机。

定时器中断中断处理的流程就是中断触发后会进行中断类型的检查和判断，找到相应的中断处理函数进行相应的中断处理，处理完毕后退出中断处理函数直至下一次的中断触发。

***

### 扩展练习 `Challenge1`

描述`ucore`中处理中断异常的流程（从异常的产生开始），其中`mov a0，sp`的目的是什么？

中断异常的流程：中断异常产生后会进入`trapentry.S`中处理，会进入下面代码的处理：

```assembly
_alltraps:
    SAVE_ALL
    move  a0, sp
    jal trap
```

在这段代码中会将将所有的寄存器的值保存到栈中，然后将栈顶指针赋值给`a0`参数寄存器，然后跳转到`trap`函数进行执行：

```c++
void trap(struct trapframe *tf) { trap_dispatch(tf); }
static inline void trap_dispatch(struct trapframe *tf) {
    if ((intptr_t)tf->cause < 0) {
        // interrupts
        interrupt_handler(tf);
    } else {
        // exceptions
        exception_handler(tf);
    }
}
```

在`trap`函数中会调用`trap_dispatch`函数，在`trap_dispatch`函数中会根据中断的类型进行相应的分类，并根据分类分别进入到中断的处理函数和异常的处理函数，在中断的处理函数和异常的处理函数中会继续根据处理的类型进行不同处理函数的操作，处理完之后跳出具体的异常处理函数。

`mov a0，sp`的目的是将栈顶指针赋值给`a0`参数寄存器，这是因为之后会调用`trap`函数，而`trap`函数需要一个`trapframe`结构体，而这个结构体存储在栈顶中，所以将栈顶指针赋值给`a0`参数寄存器后，调用`trap`函数会使用`a0`参数寄存器得到所需的结构体进行相应的处理。

`SAVE_ALL`中寄寄存器保存在栈中的位置是什么确定的？

`SAVE_ALL`中寄寄存器保存在栈中的位置是在`trapentry.S`中进行寄存器的保存处理中根据`STORE`操作的第二个参数的不同栈位置确定的。

对于任何中断，`__alltraps` 中都需要保存所有寄存器吗？请说明理由

在本程序的中断处理中，`__alltraps` 中保存了所有的寄存器的值，但是并不是所有的中断都需要保存所有的寄存器，这是因为在某些中断处理函数不需要使用某些寄存器，或者这些寄存器的值在中断处理过程中不会发生变化，此时就不需要保存这些寄存器的值以此来减少中断处理的开销。

***

### 扩展练习` Challenge2`

在`trapentry.S`中汇编代码` csrw sscratch, sp`；`csrrw s0, sscratch, x0`实现了什么操作，目的是什么？

` csrw sscratch, sp`将`sp`的值存进`sscratch`寄存器中，`csrrw s0, sscratch, x0`是将`sscratch`的值存进`s0`的寄存器中并利用`x0`的值将`sscratch`的值清零，这两条操作是进行中断处理前将sp寄存器的值进行保存，以便中断处理结束后的恢复。

`save all`里面保存了`stval scause`这些`csr`，而在`restore all`里面却不还原它们？那这样store的意义何在呢？

不还原：这是因为在中断处理的过程中并不会改变这些寄存器的值，所以不需要还原成原来的值，也有可能是这些寄存器的值是与这次特定的异常有关，异常处理完毕后也就不需要这些寄存器的值。

保存的意义：

1，在异常处理期间，这些寄存器的值可以用于调试或记录目的，以帮助开发者理解异常发生的原因和上下文。

2，在处理嵌套异常时，保存这些寄存器的值可能很有用，以便在内部异常处理完成后能够恢复对外部异常的处理。

***

### 扩展练习 `Challenge3`

这个练习是让我们补全一些异常处理函数的操作，使其触发这些异常时输出异常类型和异常指令触发地址，完成的代码如下：

```c++
 case CAUSE_ILLEGAL_INSTRUCTION:
            cprintf("Exception type:Illegal instruction\n");  
    	    cprintf("EPC: 0x%08x\n", tf->epc);    
    	    tf->epc += 4; 
            break;
 case CAUSE_BREAKPOINT:
            cprintf("Exception type: breakpoint\n");  
    	    cprintf("EPC: 0x%08x\n", tf->epc);    
    	    tf->epc += 4; 
            break;
```

整体的实现思路也是比较简单，根据不同的异常处理函数进行输出不同的异常处理的类型，同时利用`epc`存储的是异常发生前的程序执行点，利用它来输出异常指令触发地址，最后更新`epc`的值。









