// 这是一个条件编译指令，用于防止头文件被重复包含。
// 如果 __KERN_MM_VMM_H__ 这个宏没有被定义过，那么就执行下面的代码，直到遇到 #endif 为止。
// 如果已经定义过了，那么这段代码就会被编译器忽略，避免在多个源文件包含此头文件时出现重复定义等问题。
#ifndef __KERN_MM_VMM_H__
#define __KERN_MM_VMM_H__

// 包含一些自定义的头文件，这些头文件中应该定义了一些基本的数据类型、结构体以及相关的函数声明、宏定义等，
// 用于支持当前这个头文件所涉及的内存管理相关功能的实现和编译。
#include <defs.h>
#include <list.h>
#include <memlayout.h>
#include <sync.h>

// 前置声明结构体 mm_struct，在这个位置只是告诉编译器后面会用到这个结构体类型，
// 但具体的结构体定义可能在其他地方（比如后续的代码或者另一个相关的源文件中），
// 这样可以解决结构体之间相互引用时编译顺序的问题，使得代码结构可以更灵活地组织。
//pre define
struct mm_struct;

// 定义结构体 vma_struct，用于表示虚拟连续内存区域（Virtual Memory Area，VMA）。
// 在操作系统的内存管理中，VMA 是一种抽象概念，用于描述一段连续的虚拟内存范围以及其相关属性。
struct vma_struct {
    // 指向所属的 mm_struct 结构体，意味着多个 vma_struct 可以属于同一个 mm_struct，
    // 同一个 mm_struct 下的所有 vma 使用相同的页目录表（Page Directory Table，PDT）来进行地址映射，
    // 这里体现了内存管理中不同虚拟内存区域与整体内存控制结构之间的关联关系。
    struct mm_struct *vm_mm; 
    // 表示这个虚拟内存区域的起始虚拟地址，是该区域在虚拟地址空间中的起始位置，
    // 后续可以通过这个起始地址以及其他相关属性来确定此区域涵盖的范围以及进行地址合法性判断等操作。
    uintptr_t vm_start;      
    // 表示这个虚拟内存区域的结束虚拟地址，需要注意的是，这个地址本身并不包含在该虚拟内存区域内，
    // 也就是地址范围是 [vm_start, vm_end)，符合常见的区间表示习惯，方便进行地址范围的判断和处理。
    uintptr_t vm_end;        
    // 用于表示这个虚拟内存区域的标志位，通过位掩码的方式来定义不同的属性，比如是否可读（VM_READ）、可写（VM_WRITE）、可执行（VM_EXEC）等，
    // 可以根据这些标志位来控制对该虚拟内存区域的访问权限以及进行相关的内存管理操作。
    uint_t vm_flags;       
    // 用于将这个 vma_struct 结构体链接到线性链表中的节点元素，链表可以按照虚拟内存区域的起始地址进行排序，
    // 方便在内存管理中进行查找、遍历等操作，例如按照地址顺序查找某个地址所属的虚拟内存区域等。
    list_entry_t list_link;  
};

// 定义一个宏 le2vma，用于将链表节点（list_entry_t 类型）转换为对应的 vma_struct 结构体指针。
// 它通过调用 to_struct 函数（这个函数应该在其他地方定义，可能是用于进行类型转换以及从链表节点获取对应结构体的操作），
// 根据传入的链表节点指针（le）以及结构体中链表节点成员的名称（member）来获取对应的 vma_struct 结构体指针，
// 方便在操作链表时快速获取到对应的 VMA 结构体进行相关处理。
#define le2vma(le, member)                  \
    to_struct((le), struct vma_struct, member)

// 以下是定义表示虚拟内存区域不同访问权限的标志位宏，每个宏对应一个二进制位，通过按位或（|）操作可以组合多个权限。
// 表示该虚拟内存区域具有可读权限，对应二进制位为 0x00000001。
#define VM_READ                 0x00000001
// 表示该虚拟内存区域具有可写权限，对应二进制位为 0x00000002。
#define VM_WRITE                0x00000002
// 表示该虚拟内存区域具有可执行权限，对应二进制位为 0x00000004。
#define VM_EXEC                 0x00000004

// 定义结构体 mm_struct，它是用于控制一组使用相同页目录表（PDT）的虚拟内存区域（vma）的结构体，
// 可以看作是对多个相关虚拟内存区域的一个整体管理结构，包含了与内存映射、页表管理等相关的重要信息。
struct mm_struct {
    // 用于将这个 mm_struct 结构体下管理的所有 vma_struct 结构体链接成一个线性链表，
    // 链表按照 vma 的起始地址进行排序，方便进行查找、遍历等操作，例如遍历所有属于该 mm_struct 的虚拟内存区域。
    list_entry_t mmap_list;        
    // 用于缓存当前访问过的 vma_struct，是一种性能优化手段，下次再访问相近地址的虚拟内存区域时，
    // 可以先检查这个缓存，如果命中则可以更快地获取到对应的 VMA，避免每次都从头遍历链表去查找，提高内存访问效率。
    struct vma_struct *mmap_cache; 
    // 指向这个 mm_struct 管理的所有虚拟内存区域所使用的页目录表（Page Directory Table，PDT），
    // PDT 是实现虚拟地址到物理地址映射的关键数据结构，通过这个指针可以访问和操作整个页表体系来完成地址转换等功能。
    pde_t *pgdir;                  
    // 用于记录这个 mm_struct 下管理的虚拟内存区域（vma）的数量，方便在一些统计、遍历以及内存管理相关操作中使用，
    // 例如判断是否达到了虚拟内存区域数量的上限或者进行遍历循环的终止条件判断等。
    int map_count;                 
    // 用于存放交换管理器（swap manager）相关的私有数据，不同的交换管理策略或者实现可能会在这个指针指向的空间存储各自特定的数据，
    // 比如记录页面交换相关的状态、信息等，方便交换管理功能与整体内存管理协同工作。
    void *sm_priv;                   
};

// 函数声明，用于在给定的 mm_struct 结构体（代表一组虚拟内存区域）中查找包含指定虚拟地址（addr）的虚拟内存区域（vma_struct），
// 如果找到则返回对应的 vma_struct 指针，否则返回 NULL，这个函数在内存管理中用于地址所属区域的判断以及后续基于区域的操作等情况。
struct vma_struct *find_vma(struct mm_struct *mm, uintptr_t addr);
// 函数声明，用于创建一个新的虚拟内存区域（vma_struct）结构体实例，传入起始虚拟地址（vm_start）、结束虚拟地址（vm_end）以及访问权限标志（vm_flags），
// 根据这些参数初始化一个新的 vma_struct 结构体并返回其指针，方便在内存管理中动态创建新的虚拟内存区域，例如进程创建或者内存分配时需要新增区域的场景。
struct vma_struct *vma_create(uintptr_t vm_start, uintptr_t vm_end, uint_t vm_flags);
// 函数声明，用于将一个已经创建好的虚拟内存区域（vma_struct）结构体插入到指定的 mm_struct 结构体管理的虚拟内存区域链表中，
// 插入时会根据虚拟内存区域的起始地址按照顺序插入到链表合适的位置，保证链表始终是按照起始地址有序排列的，便于后续查找等操作。
void insert_vma_struct(struct mm_struct *mm, struct vma_struct *vma);

// 函数声明，用于创建一个新的 mm_struct 结构体实例，初始化相关成员变量，为管理一组新的虚拟内存区域做准备，
// 例如在创建新进程时会调用这个函数来初始化进程的内存管理相关结构，返回创建好的 mm_struct 指针。
struct mm_struct *mm_create(void);
// 函数声明，用于销毁一个给定的 mm_struct 结构体及其管理的所有虚拟内存区域相关资源，
// 例如释放链表节点、页目录表等占用的内存空间，在进程结束或者内存管理结构不再需要时调用这个函数进行资源回收。
void mm_destroy(struct mm_struct *mm);

// 函数声明，用于初始化虚拟内存管理（Virtual Memory Management，VMM）相关的全局数据结构、状态等，
// 可能包括初始化一些默认的内存管理参数、创建初始的页目录表或者设置相关的全局变量等操作，是整个虚拟内存管理模块启动时的初始化入口函数。
void vmm_init(void);

// 函数声明，用于处理页面错误（Page Fault）情况，当程序访问的虚拟地址在当前内存映射中不存在对应的物理页面时（即发生缺页中断），
// 会调用这个函数进行处理，传入发生错误的 mm_struct（代表对应的内存管理上下文）、错误码（error_code，包含了一些关于错误类型等的信息）以及触发错误的虚拟地址（addr），
// 通过这个函数来尝试解决页面错误，比如从磁盘加载页面到内存、更新页表等操作，使程序能继续正常运行。
int do_pgfault(struct mm_struct *mm, uint_t error_code, uintptr_t addr);

// 声明一个外部的 volatile 类型的无符号整数变量 pgfault_num，用于记录页面错误（Page Fault）发生的次数，
// volatile 关键字表示这个变量的值可能会在程序执行过程中被异步地修改（比如被中断处理程序修改），
// 所以编译器在优化代码时不会对这个变量的访问进行一些可能导致错误的优化操作，确保每次读取到的都是最新的值。
extern volatile unsigned int pgfault_num;
// 声明一个外部的 struct mm_struct 类型的指针变量 check_mm_struct，
// 这个变量可能用于在某些调试或者特定的内存管理检查场景下，指向一个特定的内存管理结构实例进行相关操作或者验证，
// 具体用途要结合整个项目中其他地方对它的使用情况来确定。
extern struct mm_struct *check_mm_struct;

// 结束条件编译指令的 #endif 部分，与开头的 #ifndef 对应，完成头文件的条件编译包裹，确保头文件内容的正确包含和避免重复定义。
#endif /*!__KERN_MM_VMM_H__ */